#数据  
变量的三个属性:  
+ 作用域
+ 链接属性  
+ 存储类型  
这三个属性决定了一个变量的可视性(可以在什么地方使用)和生命期(它的值将保持多久)  
  

##基本数据类型  
4种基本数据类型:  
+ 整型
+ 浮点型  
+ 指针  
+ 聚合类型(数组和结构等)  
所有其他类型都是由这四种基本类型的某种组合派生而来  
  
###整型  
包括字符,短整型,整型,长整型,都分为有符号(signed)和无符号(unsigned)  
**长整型至少应该和整型一样长,整型至少应该和短整型一样长**

####整型字面值  
字面值literal,指定了自身的值,且不允许被改变  

####枚举类型  
枚举类型就是指它的值为符号常量而不是字面值的类型  
符号名被当作整型常量处理,声明为枚举类型的变量实际上是整数类型  

###浮点类型  


###指针
####字符串常量  
c语言中字符串的概念:一串以NUL字节结尾的零个或多个字符,通常存储在字符数组中  

当一个字符串常量出现在一个表达式中时,表达式所使用的值就是这些字符所存储的地址,而不是字符本身,可以把字符串常量赋值给一个"指向字符的指针",但不能赋值给字符数组  

##基本声明  
**note**:应该使用typedef而不是#define来创建新类型名,因为后者无法处理指针类型  

##作用域  

###代码块作用域  
任何在代码块开始位置声明的标识符都具有代码块作用域(block scope),表示他们可以被这个代码块中所有的语句访问  
函数定义的形式参数在函数内部也具有代码块作用域  
当代码块处于嵌套状态时,声明于内层代码块的标识符的作用域到达该代码块的尾部便告终.然而,如果内层代码块有一个标识符的名字与外层代码块相同,则内层将隐藏外层标识符  

###文件作用域
任何在所有代码块之外声明的标识符都具有文件作用域(file scope),文件中定义的函数名也具有文件作用域,因为他们本身不属于任何代码块  

###原型作用域  
适用于在函数原型中声明的参数名
###函数作用域
只适用于语句标签

##链接属性  
当组成一个程序的各个源文件分别被编译后,所有的目标文件和函数链接在一起,形成可执行程序.不同文件出现相同标识符  
链接属性有3种:  
+ external(外部): 不论声明多少次,位于几个源文件都是一个实体
+ internal(内部): 在同一个源文件中指向同一个实体
+ none(无):多个声明总是被当作单独的个体  

static只对缺省链接属性为external的声明才具有改变链接属性的效果  
extern关键字用于源文件中一个标识符的第一次声明才有用,否则无法改变第一次声明时指定的链接属性  


##存储类型  
变量的存储类型(storage class)是指存储变量值的内存类型.变量的存储类型决定了变量何时创建,何时销毁,以及可以保持多久  
有3个地方可以存储变量:  
+ 普通内存  
+ 运行时堆栈  
+ 硬件寄存器  
变量的缺省存储类型取决于它的声明位置,凡在任何代码块之外声明的变量总存储于静态内存中,不属于堆栈的内存,称为静态变量,无法指定其他存储类型,在程序运行前创建,程序运行时始终存在,始终保持原先的值,除非被赋值或程序结束  
  
在代码块内部声明的变量的缺省存储类型是自动的auto,存储于堆栈,称为自动变量.在程序执行到声明自动变量的代码块时,自动变量才被创建,当程序的执行流离开时,自动变量销毁,再次执行时它们的值一般不是上次执行的值  

对于在代码块中声明的变量,如果加上static关键字,使得它的存储类型变为静态,具有静态存储类别的变量在整个程序执行期间一直存在.**注意修改变量的存储类型并不表示修改该变量的作用域,它仍然只能在代码块中按名字访问,函数形参不能声明为静态,因为他总是在堆栈中传递给函数**  

关键字register可以用于自动变量的声明,提示他们应该存储在机器的硬件寄存器而不是内存中,访问效率更高.寄存器变量的创建和销毁时间和自动变量系统,但需要额外的工作.当函数开始执行时,将寄存器中的内容保存到堆栈,函数返回后再复制回寄存器  

##static关键字  
+ 用于函数时,或代码块之外的变量时,修改标识符的链接属性,从external改为internal  
+ 用于代码快内部的变量声明时,修改变量的存储类型,从自动变量改为静态变量,但链接属性和作用域不受影响  


