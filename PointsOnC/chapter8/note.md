#数组  
##一维数组  
在c中,在几乎所有使用数组名的表达式中,数组名的值是一个指针常量,也就是数组第1个元素的地址.它的类型取决于数组元素的类型,所以数组名的类型就是"指向其它类型的常量指针"  
数组具有一些和指针完全不同的特征,例如,数组具有确定数量的元素,而指针只是一个标量值.编译器用数组名来记住这些属性,只有当数组名在表达式中使用时,编译器才会为他产生一个指针常量  
**note:**  
这个值是一个指针常量,而不是指针变量.不能修改这个值.指针常量所指向的是内存中数组的起始位置,如果修改这个指针常量,唯一可行的操作就是把整个数组移动到内存的其他位置,但是,在程序完成链接之后,内存中数组的位置是固定的,所以此时再移动数组为时已晚  
只有在两种场合下,数组名不能用指针常量来表示:数组名作为sizeof操作符或单目操作符&的操作数时,sizeof返回数组长度而不是指向数组的指针长度,取一个数组名的地址所产生的是一个指向数组的指针,而不是某个指针常量值的指针  

###指针与下标  
**假定两种方法都正确,下标绝不会比指针更有效率,指针有时比下标更有效率**  
示例代码:  
```c
//下标版本
int array[10], a;
for (a = 0; a < 10; a++)
    array[a] = 0; //有乘法和加法


//指针版本
int array[10], *ap;

for (ap = array; ap < array + 10; ap++)
    *ap = 0;  //仅包含一条指令 将4与指针相加
```

最高效的复制数组代码  
```c

void copy() {
    register int *p1, *p2;
    for (p1 = x, p2 = y; p1 < &x[SIZE];)
        *p1++ = *p2++;
}
```
具体对比见page149
结论:  
+ 当根据某个固定数量的增量在一个数组中移动时,指针变量比下标变量更加高效  
+ 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高  
+ 那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高,常量表达式可以在编译期间求得  

###指针和数组  
```c
int a[10];
int *b;
```
声明一个数组时,编译器根据声明所指定的元素数量为数组保留内存空间,然后再创建数组名,它是一个常量,指向这段空间的起始位置.声明一个指针变量时,编译器只为指针本身保留内存空间,不为任何整型值分配空间,而且指针变量并未被初始化为指向任何现有的内存空间  
因此表达式*a是合法的,而*b是非法的,这将访问内存中某个不确定的位置,或导致程序终止.b++是可以通过编译的,而a++不行,因为他是个常量  

###初始化  



