#数组  
##一维数组  
在c中,在几乎所有使用数组名的表达式中,数组名的值是一个指针常量,也就是数组第1个元素的地址.它的类型取决于数组元素的类型,所以数组名的类型就是"指向其它类型的常量指针"  
数组具有一些和指针完全不同的特征,例如,数组具有确定数量的元素,而指针只是一个标量值.编译器用数组名来记住这些属性,只有当数组名在表达式中使用时,编译器才会为他产生一个指针常量  
**note:**  
这个值是一个指针常量,而不是指针变量.不能修改这个值.指针常量所指向的是内存中数组的起始位置,如果修改这个指针常量,唯一可行的操作就是把整个数组移动到内存的其他位置,但是,在程序完成链接之后,内存中数组的位置是固定的,所以此时再移动数组为时已晚  
只有在两种场合下,数组名不能用指针常量来表示:数组名作为sizeof操作符或单目操作符&的操作数时,sizeof返回数组长度而不是指向数组的指针长度,取一个数组名的地址所产生的是一个指向数组的指针,而不是某个指针常量值的指针  

###指针与下标  
**假定两种方法都正确,下标绝不会比指针更有效率,指针有时比下标更有效率**  
示例代码:  
```c
//下标版本
int array[10], a;
for (a = 0; a < 10; a++)
    array[a] = 0; //有乘法和加法


//指针版本
int array[10], *ap;

for (ap = array; ap < array + 10; ap++)
    *ap = 0;  //仅包含一条指令 将4与指针相加
```

最高效的复制数组代码  
```c

void copy() {
    register int *p1, *p2;
    for (p1 = x, p2 = y; p1 < &x[SIZE];)
        *p1++ = *p2++;
}
```
具体对比见page149
结论:  
+ 当根据某个固定数量的增量在一个数组中移动时,指针变量比下标变量更加高效  
+ 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高  
+ 那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高,常量表达式可以在编译期间求得  

###指针和数组  
```c
int a[10];
int *b;
```
声明一个数组时,编译器根据声明所指定的元素数量为数组保留内存空间,然后再创建数组名,它是一个常量,指向这段空间的起始位置.声明一个指针变量时,编译器只为指针本身保留内存空间,不为任何整型值分配空间,而且指针变量并未被初始化为指向任何现有的内存空间  
因此表达式*a是合法的,而*b是非法的,这将访问内存中某个不确定的位置,或导致程序终止.b++是可以通过编译的,而a++不行,因为他是个常量  

###初始化  

##二维数组  
```c
int matrix[3][10];
```
创建了matrix,他可以看作是一个一维数组,每个元素是包含10个整型元素的数组  
matrix这个名字的值是一个指针,指向一个包含10个整型元素的数组的指针.因此注意无法把多维数组的数组名赋值给整型指针  
```c
int vector[10], *vp = vector; //OK
int matrix[3][10], *mp = matrix; //ERROR
int (*p)[10] = matrix; //OK
```

**note**:
当你打算在指针上执行任何指针运算时,应该避免这种类型的声明:  
```c
int (*p)[] = matrix;
```
形参是二维数组的函数原型:  
```c
int func(int (*mat)[10]);//OK
int func(int mat[][10]); //OK
int func(int ** mat); //ERROR
```
最后一个例子把mat声明为指向整型指针的指针,与指向整型数组的指针并不是一回事  


##指针数组  
```c
char * keyword[] = {
        "do",
        "for",
        ...,
        NULL;
        
};
```
此种方法无需知道数组的长度

##register关键字  
register修饰符暗示编译程序相应的变量将被频繁使用,如果可能的话,应将其保存在cpu寄存器中,加快存储速度  
限制:  
+ register变量必须是能被cpu所接受的类型,必须是一个
  单个的值,长度应该小于等于整型的长度,也有些机器的寄存器可以存放浮点型  
+ 可能不存放在内存中,所以不能使用&获取地址  
+ 只有局部自动变量和形式参数可以作为寄存器变量,全局变量不行  
+ 局部静态变量不能定义为寄存器变量



