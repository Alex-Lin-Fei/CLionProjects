#结构和联合
##结构基础知识  
###声明  
struct tag {member-list} variable-list  

###结构的自引用  
在一个结构内部包含一个类型为该结构本身的成员是不合法的,但是可以包含该类型的指针

###不完整的声明  
一些相互之间存在依赖的结构,其中一个结构包含了另一个结构的一个或多个成员,至少有一个结构必须在另一个结构内部以指针形式存在,问题在于声明部分:如果每个结构都引用了其他结构的标签
```c

struct A {
    struct B * partner;
};

struct B {
    struct A * partner;
};

```
不不过目前似乎并不需要不完整的声明了  

##结构的存储分配  
编译器按照成员列表的顺序一个接一个地给每一个成员分配内存,只有当存储成员时需要满足正确的边界对其要求时,成员之间才可能出现用于填充的额外内存空间  
系统禁止编译器在一个结构的起始位置跳过几个字节来满足边界对齐要求,因此所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置  
**结构体的大小计算**:  
结构体计算要遵循字节对齐原则  
+ 结构体变量的首地址能够满足被其最宽基本成员的大小所整除
+ 结构体每个成员相对结构体首地址的偏移量都是成员大小的整数倍,如有需要编译器会在成员之间加上填充字节  
+ 结构体的总大小为结构体最宽基本类型成员大小的整数倍,如有需要编译器会在最后一个成员之后填充字节  

##作为函数参数的结构  
应该传递结构体变量类型的指针(调用时取地址即可)而不是结构体类型形参  

##位段  
不可移植  
##联合体  
一个联合的所有成员都存储在同一个内存位置.通过访问不同类型的联合成员,内村中相同的位组合可以被解释为不同的东西.联合在变体记录中很有用,但程序员必须负责确认实际存储的是哪个变体并选择正确的联合成员以便访问数据,联合变量可以初始化,但初始值必须与联合第一个成员的类型匹配  

