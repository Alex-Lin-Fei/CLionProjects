#多维数组的内存布局
单个元素的存储与引用实际上是以线性形式排列在内存中的,因此,pea[i][j]将被编译器解析为  
*(*(pea + i) + j)  
"pea[i]"的意思将**随着pea的定义的不同而变化**  

#指针数组就是向量
两个下标的二维数组和一维数组所存在的一个问题是:当你看到squash[i][j]这样的引用形式时,你并不知道squash的声明是:
```c
int squash[23][12]; /*int 类型的二维数组*/
int *squash[23];    /*23个int类型指针的iliffe向量*/
int **squash;       /*int 类型的指针的指针*/
int (*squash)[12];   /*类型为int的数组(长度为12)的指针*/
```
这有点类似在函数内部无法分辨传递给函数的实参究竟是一个数组还是一个指针.当然,基于同样的理由:**作为左值的数组名被编译器当作是指针**  
在上面几种定义中,都可以使用如squash[i][j]这样的形式,尽管在不同的情况中访问的实际类型并不相同  
指针下标引用的规则告诉我们pea[i][j]被编译器解释为:  
```c
*(*(pea+i)+j)
```
尽管这两种下标形式在源代码里看上去是一样的,而且被编译器解释为同一种指针表达式,但它们在各自的情况下所引用的实际类型并不相同  
##一个数组的数组char a[4][6]
char a[4][6]--一个数组的数组  
在编译器符号表中,a的地址为9980  
运行时步骤1: 取i的值,把它的长度调整为一行的宽度(这里是6),然后加到9980上  
运行时步骤2:取j的值,把它的长度调整为一个元素的宽度(这里是1),然后加到前面所得的结果上  
运行时步骤3:从地址(9980 + i*scale-factor1 + j*scale-factor2)中取出内容
##字符串指针数组中的char * p[4]  
char * p[4] -- 一个字符串指针数组  
在编译器符号表中,p的地址为4624  
运行时步骤1:取i的值,乘以指针宽度(x86系统是4个字节, x64系统8个字节),并把结果加到4634上  
运行时步骤2:从地址(4624+4/8*i)取出内容,为"5081"  
运行时步骤3:取j的值,乘以元素的宽度(这里是1个字节),并把结果加到5081上  
运行时步骤4:从地址(5081+j*1)取出内容  

#在锯齿状数组上使用指针  
数组和指针参数是如何被编译器修改的  
"数组名被改写成一个指针参数"规则并不是递归定义的.数组的数组会被改写成"数组的指针"而不是"指针的指针"  
            实参                      所匹配的形式参数
数组的数组   char c[8][10]          char (*)[10]           数组指针
指针数组     char * c[15]           char ** c              指针的指针
数组指针     char (*c)[64]           char (*c)[64]         不改变
指针的指针   char ** c              char  **c               不改变