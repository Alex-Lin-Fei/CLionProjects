#多维数组的内存布局
单个元素的存储与引用实际上是以线性形式排列在内存中的,因此,pea[i][j]将被编译器解析为  
*(*(pea + i) + j)  
但是"pea[i]"的意思将**随着pea的定义的不同而变化**  

#指针数组就是向量
两个下标的二维数组和一维数组所存在的一个问题是:当你看到squash[i][j]这样的引用形式时,你并不知道squash的声明是:
```c
int squash[23][12]; /*int 类型的二维数组*/
int *squash[23];    /*23个int类型指针的iliffe向量*/
int **squash;       /*int 类型的指针的指针*/
int (*squash)[12];   /*类型为int的数组(长度为12)的指针*/
```
这有点类似在函数内部无法分辨传递给函数的实参究竟是一个数组还是一个指针.当然,基于同样的理由:**作为左值的数组名被编译器当作是指针**  
在上面几种定义中,都可以使用如squash[i][j]这样的形式,尽管在不同的情况中访问的实际类型并不相同  
指针下标引用的规则告诉我们pea[i][j]被编译器解释为:  
```c
*(*(pea+i)+j)
```
尽管这两种下标形式在源代码里看上去是一样的,而且被编译器解释为同一种指针表达式,但它们在各自的情况下所引用的实际类型并不相同  
##一个数组的数组char a[4][6]
char a[4][6]--一个数组的数组  
在编译器符号表中,a的地址为9980  
运行时步骤1: 取i的值,把它的长度调整为一行的宽度(这里是6),然后加到9980上  
运行时步骤2:取j的值,把它的长度调整为一个元素的宽度(这里是1),然后加到前面所得的结果上  
运行时步骤3:从地址(9980 + i*scale-factor1 + j*scale-factor2)中取出内容
##字符串指针数组中的char * p[4]  
char * p[4] -- 一个字符串指针数组  
在编译器符号表中,p的地址为4624  
运行时步骤1:取i的值,乘以指针宽度(x86系统是4个字节, x64系统8个字节),并把结果加到4634上  
运行时步骤2:从地址(4624+4/8*i)取出内容,为"5081"  
运行时步骤3:取j的值,乘以元素的宽度(这里是1个字节),并把结果加到5081上  
运行时步骤4:从地址(5081+j*1)取出内容  

#在锯齿状数组上使用指针  
存储各行长度不一的表以及在一个函数调用中传递一个字符串数组.如果需要存储50个字符串,每个字符串的最大长度可以达到255个字符,可以声明以下的二维数组:  
```c
char carrot[50][256];
```
它声明了50个字符串,每个都保留256个字节的空间,即使有些字符串的实际长度只到一两个字节,这样做内存浪费很大,一种替代方法就是使用字符串指针数组,注意到它所有第二级数组并不需要长度相同  
如果声明一个字符串数组,并根据需要为这些字符串分配内存,将会大大节省空间,称之为"锯齿状数组",因为右端的长度不一,可以共享字符串或者分配内存拷贝一份:  
```c
char * turnip[UMPTEEN];
char my_string[] = "your message here";

/*共享字符串*/
turnip[i] = &my_string[0];
/*拷贝字符串*/
turnip[i] = malloc(strlen(my_string) + 1);
strcpy(turnip[i], my_string);
```
##数组和指针参数是如何被编译器修改的  
"数组名被改写成一个指针参数"规则并不是递归定义的.数组的数组会被改写成"数组的指针"而不是"指针的指针"  
            实参                      所匹配的形式参数
数组的数组   char c[8][10]          char (*)[10]           数组指针
指针数组     char * c[15]           char ** c              指针的指针
数组指针     char (*c)[64]           char (*c)[64]         不改变
指针的指针   char ** c              char  **c               不改变  


#使用指针从函数返回一个数组  
严格来说,无法直接从函数中返回一个数组.但是,可以让函数返回一个指向任何数据结构的指针,也可以是一个指向数组的指针  
```c

int (*paf())[20] {
    int (*pear)[20];
    pear =calloc(20, sizeof(int));
    if (!pear)
        ;
    return pear;
}

int main() {
int (*res)[20];
res = paf();
(*res)[1] = 12;
printf("%d, %d\n", (*res)[0], (*res)[1]);

return 0;
}
//console
0, 12
```
#calloc malloc realloc  
##malloc  
malloc函数,其原型为void* malloc(unsigned int num_bytes)  
num_byte为要申请的空间大小,需要手动计算,如 int * p = (int*)malloc(20 * sizeof(int)),一次性申请80字节的连续空间,并将空间基地址强制转换为int类型,赋值给指针p,此时申请的内存值是不确定的  

##calloc  
calloc函数,其原型为calloc(size_t n, size_t size);  
并不需要人为计算空间的大小,如int * p = calloc(20, sizeof(int)).calloc在申请之后,对空间的值逐一初始化,设置为0  

##realloc  
realloc函数,原型realloc(void *ptr, size_t new_size),用于对动态内存进行扩容(及已申请的动态空间不够使用,需要进行空间扩容操作),ptr所指原来的空间基址指针,new_size为将来需要扩充容量的大小  
如果size较小,原来申请的动态内存后面还有空余内存,系统将直接在原内存空间后进行扩容,返回原动态空间基址;如果size较大,系统将重新申请一块内存并把原来的内容拷贝过去,原来空间free;如果size非常大,系统内存申请失败,  
返回null,原先内存不会释放.